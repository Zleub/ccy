// ************************************************************************** //
//                                                                            //
//                                                        :::      ::::::::   //
//   optimal_arbitrage.js                               :+:      :+:    :+:   //
//                                                    +:+ +:+         +:+     //
//   By: fjanoty <marvin@42.fr>                     +#+  +:+       +#+        //
//                                                +#+#+#+#+#+   +#+           //
//   Created: 2018/03/23 00:27:38 by fjanoty           #+#    #+#             //
//   Updated: 2018/03/23 06:17:26 by fjanoty          ###   ########.fr       //
//                                                                            //
// ************************************************************************** //

const binance = require('../node-binance-api.js');
binance.options({
  'APIKEY':'<api key>',
  'APISECRET':'<api secret>'
});


var	crypto_nb = 0;
var	name_to_id = [];
var id_to_name = [];
var	centre_name = [];

var	link_nb = 0;
var	lst_link_id = [];
var	lst_link_name = [];

var	mat_connexion = [];
var	mat_bid_ask = [];

var	lst_equivalent = [];
var lst_cycle = [];

var all_cycle = [];			// la liste de tout les cycle concernant les crypto [C]entral et donc enfait ses chemin equivalent [taille du cycle][id_cycle][liste des point parcouru]

var	interne_couples = [];			// la lite des connexion intern --> en fait juste une matrice 4 x 4, donc leur valeur
var interne_couples_link = []		// le truc qui passe
var	list_cycle = [];				// [lenght][lst] = [id1, id2, id3]; 

//		{id_inter, v1, v2, gain}

function	init_name()
{
	name_to_id["USDT"] = 0;
	name_to_id["BTC"] = 1;
	name_to_id["ETH"] = 2;
	name_to_id["BNB"] = 3;

	id_to_name = ["USDT", "BTC", "ETH", "BNB"];

	centre_name["USDT"] = 0;
	centre_name["BTC"] = 1;
	centre_name["ETH"] = 2;
	centre_name["BNB"] = 3;

	crypto_nb = 4;
}

function get_crypto_name(couple)
{
	let	name = {target:"", ref:""};
	let end1;
	let	len;

	end1 = couple.slice(-3);
	if (centre_name[end1] == undefined)
	{
		end1 = couple.slice(-4);
		if (centre_name[end1] == undefined) // les cas un peu bizar
		{
			console.log("error===>", end1);
			return (undefined);
		}
	}
	len = end1.length;
	name.target = couple.slice(0, -len);
	name.ref = end1;
	return (name);
}

//	on va aussi definir les liens
function	forge_the_names_and_links(bid_ask)
{
	var name = {};
	for (id in bid_ask)
	{
		name = get_crypto_name(bid_ask[id].symbol);
		if (name == undefined)
		{
			console.log("						C'EST LA GUERRE!");	// 
			continue ;
		}
		if ((name_to_id[name.target]) == undefined)
		{
			name_to_id[name.target] = crypto_nb;
			id_to_name[crypto_nb] = name.target;
			crypto_nb++;
		}

		let id_from, id_to;
		id_from = name_to_id[name.ref];
		id_to = name_to_id[name.target];
		lst_link_id[link_nb] = {from : id_from, to : id_to};
		lst_link_name[link_nb] = {from : name.ref, to : name.truc};
		link_nb++;
	}
}

function	matrix_init_connecion_bidask()
{
	for (j = 0; j < crypto_nb; j++)
	{
		mat_connexion[j] = [];
		mat_bid_ask[j] = [];
		for (i = 0; i < crypto_nb; i++)
		{
			mat_connexion[j][i] = 0;
			mat_bid_ask[j][i] = 0;
		}
	}
}

function	make_bid_ask_matrix(ticker)
{
	let id1, id2;
	var	name = {from:"", to:""};	
	var id = {from:-1, to:-1};

	matrix_init_connecion_bidask();	// on initialise les tableau sur lequel on va travailer
	//	on enregister toute es connexion par un un aux croisement de la colone i et la ligne j
	//	Ca permet d'estimet le nombre de conexiion qui existe entre deux neoeud quand on calcule une puissance de cette matrice
	for (id in lst_link_id)
	{
		id1 = lst_link_id[id].from;		// crypto [C]entral 
		id2 = lst_link_id[id].to;		// crypto [P]eriferique
		mat_connexion[id1][id2] = 1;	
		mat_connexion[id2][id1] = 1;	
	}
	//	On fait la meme chose mais cette fois on enregistre la valeur de l'echange
	for (id in ticker)
	{
		name = get_crypto_name(ticker[id].symbol);
		if (name == undefined)
			continue ;
		id1 = name_to_id[name.ref];
		id2 = name_to_id[name.target];
		mat_bid_ask[id1][id2] = ticker[id].askPrice;		// C -> P: ask 
		mat_bid_ask[id2][id1] = ticker[id].bidPrice;    	// P -> C: bid
//		console.log("===> ", ticker[id]);
	}
}

function	make_equivalent_path()
{
	let i, j, k, id;
	// on va d'abord lister tout les chemin equivalent des crypto [C]entral
	//		C'est toute les association de deux nombre compris entre 0 et 3 inclus dont les deux nombre sont different
	// ici on va faire des liste des crypto [P]eripherique qui sont eligible a l'euivalence d'une conexion de crypto [C]entral
	
	for (j = 0; j < 4; j++)
	{
		lst_equivalent[j] = [];
		for (i = 0; i < 4; i++)
		{
			if (i == j)
				continue ;
			// --> la on va chercher pour toute les monnaie celle qui sont conecter a [i] et a [j]
			lst_equivalent[j][i] = [];
			id = 0;
			for (k = 4; k < crypto_nb; k++) // on ne cherche pas dans les parent, on pourrais mais non
			{
				if (mat_connexion[k][i] == 1 && mat_connexion[k][j]) // on a bien les baille
				{
					lst_equivalent[j][i][id] = lst_link_id[k];
					id++;
				}
			}
		}
	}
}

function	set_hard_cycle4()
{
	lst_cycle = [	[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3],
			[0, 1, 2], [2, 1, 0], [1, 2, 3], [3, 2, 1], [0, 2, 3], [3, 2, 0], [0, 3, 1], [1, 3, 0],
			[0, 1, 3, 2], [0, 2, 3, 1], [0, 1, 2, 3], [0, 3, 2, 1], [0, 2, 1, 3], [0, 3, 1, 2]];
}

function	eval_path()
{
}


function	compare_cycle()
{

}

function	print_statment()
{
	let id1, id2, str = "", i, j;

	//////		On imprime la liste de tout les nom
	console.log("lst of name:");
	for (i in id_to_name)
	{
		console.log("    ", id_to_name[i]);
	}

	/////		On imprime la liste des connexion en associant les id aux nom
	console.log("lst of connexion:");
	for (i in lst_link_id)
	{
		id1 = lst_link_id[i].from;
		id2 = lst_link_id[i].to;
		console.log("    [", id1, "][", id2, "]:--> {", id_to_name[id1],":",  id_to_name[id2],"}");
	}


///////////// Les matrice qui prenne de la place //////////////////////
//	for (j in mat_connexion)                                         //
//	{                                                                //
//		str = "";                                                    //
//		for (i in mat_connexion[j])                                  //
//			str += ("" + mat_connexion[j][i] + "").padStart(3);      //
//		console.log("      ", str);                                  //
//	}                                                                //
//	console.log("\n\n\n\n");                                         //
//	for (j in mat_bid_ask)                                           //
//	{                                                                //
//		str = "";                                                    //
//		for (i in mat_bid_ask[j])                                    //
//			str += (" |" + mat_bid_ask[j][i] + "|").padStart(3);     //
//		console.log("      ", str);                                  //
//	}                                                                //
///////////////////////////////////////////////////////////////////////

	/////		On imprime une matrice de conexino
}

function	do_all_the_taf(bid_ask)
{
	var name = {};
	
	init_name();
	forge_the_names_and_links(bid_ask);
	make_bid_ask_matrix(bid_ask);
	print_statment();
//		console.log(bid_ask[id].symbol);
}

binance.bookTickers((error, ticker) => {
//	  console.log("bookTickers()", ticker);
	do_all_the_taf(ticker);
});

/*
{ symbol: 'QTUMUSDT',
  bidPrice: '18.99900000',
  bidQty: '12.09100000',
  askPrice: '19.01900000',
  askQty: '24.00600000' }

*/
